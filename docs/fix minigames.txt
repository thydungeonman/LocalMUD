LocalMUD Minigame Integration Plan Prepared for future implementation when fresh and focused

ğŸ§­ Goal
Convert standalone minigames (like Blackjack and combat) into fully integrated parser-native experiences, so they feel like part of the world rather than separate modules. Avoid bloating parser.py while keeping gameplay modular and maintainable.

ğŸ§© Architecture Overview
1. Minigame Router Module Create game/minigame_router.py to handle all minigame-related commands. Parser checks if a minigame is active and forwards input:

python
if player.get("minigame_active"):
    from game.minigame_router import handle_minigame_command
    return handle_minigame_command(raw, player, game_state, message_log)
2. Individual Minigame Modules Each minigame lives in its own file under game/minigames/ (e.g., blackjack.py, dice_duel.py). Each module exposes:

start(player, message_log) â€” initializes game state

handle_command(raw, player, message_log) â€” processes input

end(player) â€” cleans up and exits the game

Minigame state is stored in player["minigame_data"].

3. Room-Based Activation Rooms can include minigame triggers via room["features"]:

python
"features": {
    "blackjack_table": {
        "type": "minigame",
        "game": "blackjack"
    }
}
Parser detects play blackjack_table and calls the appropriate start() function.

4. Command Flow Once active, player input is routed to the minigame module. Example commands:

blackjack start

hit

stand

blackjack quit

All output is appended to message_log, not printed via curses.

5. Cleanup and Return to Parser When the game ends:

Clear player["minigame_active"]

Optionally log results or stats

Return control to normal parser flow

ğŸ§¼ Benefits
Keeps parser.py clean and focused

Makes minigames feel like part of the world

Allows easy expansion (just drop in new modules)

Supports room-based flavor and NPC reactions

Enables persistent stats, gold rewards, and narrative hooks

ğŸ“ Suggested Next Steps (when ready)
[ ] Create minigame_router.py with basic dispatch logic

[ ] Refactor Blackjack into minigames/blackjack.py with start() and handle_command()

[ ] Add player["minigame_active"] and player["minigame_data"] scaffolding

[ ] Update one room to include a blackjack table feature

[ ] Add parser support for play <feature> to trigger minigames

[ ] Test flow: start â†’ hit/stand â†’ resolve â†’ return to parser

Notes to Self

Keep message_log as the only output channel

Avoid curses calls inside minigame modules

Consider adding a minigame_stats dict to player for tracking wins/losses

Use this system for future games like dice duels, riddles, or tavern gossip

Let me know when youâ€™re ready to implement and Iâ€™ll walk you through the first module.